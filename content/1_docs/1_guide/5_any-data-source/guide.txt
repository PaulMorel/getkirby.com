Title: Virtual pages

----

Intro: In Kirby, you can integrate data from any data source and use them as if they were real Kirby pages, including creating and editing their content in the Panel.

----

Text:

Since Kirby is a flat-file CMS, pages that make up your website usually exist as files and folders in the filesystem. This has many advantages: your web project can be version controlled, you don't have to deal with a database, it's easy to make backups, you can manually edit your content if you want, and last not least, it's also very fast. At least up to a certain point where it doesn't scale too well any more.

From the early days of Kirby, it was possible to include data from other sources into your Kirby-built website. But with our new architecture, you can really integrate content from any sources–from databases, from external APIs, or Excel sheets–you name them. 

You can swap out Kirby's storage mechanism on a per-model basis, just like you can replace almost any Kirby component, allowing you to flexibly combine all sorts of data sources.

This section will you an overview about all the possibilites Kirby offers.

Virtual pages can be used to just consume content from other sources, for example, from a read-only API. Or you can actually create adaptors to read from and write to database tables, spreadsheets or whatever.

<info>
We refer to anything that does not exists as folders and files as "virtual pages".
</info>

## The most simple form of a virtual page

Using Kirby's router, you can quickly create a new page from a route pattern:

```php "/site/config/config.php"
<?php

return [
    'routes' => [
        [
          'pattern' => 'virtual',
          'action'  => function () {
                $data = [
                    'slug' => 'virtual',
                    'parent' => null,
                    'template' => 'virtual',
                    'model' => 'virtual',
                    'content' => [
                        'title' => 'This is not a real page',
                        'date'  => '2019-05-01',
                        'text'  => 'The Big Oxmox advised her not to do so, because there were thousands of bad Commas, wild Question Marks and devious Semikoli, but the Little Blind Text didn’t listen.'
                    ]
                ];
                return Page::factory($data);
          }
        ]
    ]
];
```

Create a `virtual.php` template to output the content of the virtual page:

```php "/site/templates/virtual.php"

<?php snippet('header') ?>
<main>
  <article class="note">
    <header class="note-header intro">
      <h1><?= $page->title() ?></h1>
      <time class="note-date"><?= $page->date()->toDate('d F Y') ?></time>
    </header>

    <div class="note-text text">
      <?= $page->text()->kt() ?>
    </div>
  </article>
</main>
<?php snippet('footer') ?>
```

If you now open `http://yourdomain.com/virtual` in the browser, you will see the new page.

It's also possible to create a multi-language version of this page, by adding the `translations` array with the content for every language version.


```php "/site/config/config.php"
<?php

return [
    'languages' => true,
    'routes' => [
        [
          'pattern' => '(de|en)/virtual',
          'action'  => function ($lang) {
                $data = [
                    'slug' => 'virtual',
                    'parent' => page('notes'),
                    'template' => 'default',
                    'num' => '20190501',
                    'translations' => [
                        'en' => [
                            'code' => 'en',
                            'content' => [
                                'title' => 'This is not a real page',
                                'date'  => '2019-05-01',
                                'text'  => 'The Big Oxmox advised her not to do so, because there were thousands of bad Commas, wild Question Marks and devious Semikoli, but the Little Blind Text didn’t listen.'
                            ]
                        ],
                        'de' => [
                            'code' => 'de',
                            'content' => [
                                'title' => 'Das ist keine Seite',
                                'date'  => '2019-05-01',
                                'text'  => 'Weit hinten, hinter den Wortbergen, fern der Länder Vokalien und Konsonantien leben die Blindtexte. Abgeschieden wohnen sie in Buchstabhausen an der Küste des Semantik, eines großen Sprachozeans.'
                        ]
                        ]
                    ],               
                ];
                $page = Page::factory($data);
                site()->visit($page, $lang);
                
                return $page;
          }
        ]
    ]
];
```

These hard coded examples are not that useful yet, but they should already give you an idea how the `factory` method helps us to create pages from whatever content we pass to it.

## Consuming content from an API

For this example, we use a freely accessible API, in this case the (link: https://developer.nytimes.com/docs/movie-reviews-api/1/overview text: New York Times Movie Review API).

To follow this example, create an account and an example app (link: https://developer.nytimes.com/get-started text: by following the instructions).

First, create a parent page, e.g. `reviews` in the `/content` folder and inside it, a `reviews.txt` text file.

```kirbycontent "/content/reviews/review.txt"
   Title: Movie reviews

   ----
   Intro: This page lists all available movie reviews from the NYT movie review API.
```   
This page will serve as the our model for child pages.

### The page model

In the `Reviews` page model, we redefine the `children()` method to get the subpages from the API instead of from the file system:

```php "/site/models/reviews.php"
<?php

class ReviewsPage extends Kirby\Cms\Page
{
    public function children()
    {
        $results = [];
        $request = Remote::request('https://api.nytimes.com/svc/movies/v2/reviews/picks.json?api-key=api-key');

        if ($request->info['http_code'] === 200) {
        $content = json_decode($request->content());
        $results = $content->results;
        };

        $pages = [];
        foreach ($results as $key => $review) {
            $pages[] = [
                'slug'     => str::slug($review->display_title),
                'num'      => $key+1,
                'template' => 'review',
                'content'  => [
                    'title'            => $review->display_title,
                    'headline'         => $review->headline,
                    'byline'           => $review->byline,
                    'summary_short'    => $review->summary_short,
                    'publication_date' => $review->publication_date,
                    'link_url'         => $review->link->url,
                    'link_title'       => $review->link->suggested_link_text,
                    'image_link'       => $review->multimedia->src

                ]
            ];
        }
        return Pages::factory($pages, $this);
    }
}
```
</info>
Replace `api-key` with the API key you got for your app.
</info>

Using the `Remote::request()` method, you connect to the API and fetch the results. Within the foreach loop, you feed the results into the `$pages` array and finally pass it all to the `Pages::factory()` method.

### The overview template

The pages are now accessible in the template and you can loop through them like through a normal set of Kirby pages, using the fields defined in the `content` array:


```php "/site/templates/reviews.php"
<?php snippet('header') ?>

<main>
  <header class="intro">
    <h1><?= $page->title() ?></h1>
  </header>
<?php dump($page->children()) ?>
  <ul class="albums"<?= attr(['data-even' => $page->children()->listed()->isEven()], ' ') ?>>
    <?php foreach ($page->children() as $review): ?>
    <li>
      <h2><?= $review->title() ?></h2>
      <a href="<?= $review->url() ?>">Read review summary</a>
    </li>
    <?php endforeach ?>
  </ul>
</main>

<?php snippet('footer') ?>
```

### The child page template

For the children themselves, you can create their own `review.php` template to access more defails:

```php "/site/templates/review.php"
<?php snippet('header') ?>

<main>
  <article class="note">
    <header class="note-header intro">
      <h1><?= $page->title() ?></h1>
      <time class="note-date"><?= $page->publication_date()->toDate('d F Y') ?></time>
    </header>

    <div class="note-text text">
    <h2><?= $page->headline() ?></h2>
    <p>by <?= $page->byline() ?></p>
      <?= $page->summary_short() ?>
      <?php if ($page->image_link()->isNotEmpty()) ?>
      <img src="<?= $page->image_link() ?>" alt="">
    </div>
  </article>
</main>

<?php snippet('footer') ?>
```

The result should then look something like this:

(screenshot: review.png)

## Reading from and writing to a database

Content can also come from a database. This is particularly useful if you already have a large set of data stored in a MySQL or other relational database, like a huge database of products or articles. In only a few steps you can transform data from those databases into Kirby pages that behave like any Kirby page in the frontend, i.e. you can use Kirby's API to access, filter or search content, and edit it in the Panel together with all your file based content.

Our cookbook recipe (link: docs/cookbook/content/pages-from-database text: "Creating pages from a database") has an example how to connect to a database with comments and create pages from content in that database–including editing this data store from within the Panel.


## A `.csv` example

The hooks on the (link: docs/reference/system/options/hooks text: `hooks`) page are read from a `.csv` file using this page model:

```php
<?php

class HooksPage extends Page
{

    public function children()
    {
        $children = array_map(function ($hook) {
            return [
                'slug'     => Str::slug($hook['Name']),
                'template' => 'hook',
                'model'    => 'hook',
                'num'      => 0,
                'content'  => [
                    'title' => $hook['Name'],
                    'arguments' => implode(', ', Str::split($hook['Arguments'])),
                    'type' => $hook['Type']
                ]
            ];
        }, csv($this->root() . '/hooks.csv'));

        return Pages::factory($children, $this);
    }

}
```
The page model above uses a little `csv()` helper function to read from the file:

```php "/site/plugins/helpers/index.php"
function csv(string $file): array
{

    $lines = file($file);
    $lines[0] = str_replace("\xEF\xBB\xBF", '', $lines[0]);

    $csv = array_map('str_getcsv', $lines);

    array_walk($csv, function(&$a) use ($csv) {
        $a = array_combine($csv[0], $a);
    });

    array_shift($csv);

    return $csv;
}
```

You can now add a template for both the parent and the child pages and can render the data in the frontend as before.

If you want to edit the data via the Panel, you have to add blueprints for both the parent and the children. If you would now edit the entries via the Panel or add new entries, those entries would be created in the file system. To actually edit records and write them back to the `.csv` file, you need to overwrite the relevant methods like in the database example above, using a CSV manipulation library like (link: https://csv.thephpleague.com text: league/csv) to make your live easier.

## Other sources

In the same way as in the database example from the cookbook, you can write adaptors for all sorts of APIs that allow reading and writing, for example the (link: text: Google Sheets API) or the (link: text: Airtable API). A page model is all you need.

## Caching results

